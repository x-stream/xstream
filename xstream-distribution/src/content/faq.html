<html>
  <head>
    <title>Frequently Asked Questions</title>
  </head>

  <body>

  	<ol>
  		<li><a href="#Compatibility">Compatibility</a></li>
  		<li><a href="#Serialization">Serialization</a></li>
  		<li><a href="#XML">XML specifics</a></li>
  		<li><a href="#Other_Products">Comparison to other products</a></li>
  		<li><a href="#Scalability">Scalability</a></li>
    	<li><a href="#Uses">Uses of XStream</a></li>
    	<li><a href="#Development">Development</a></li>
  	</ol>

    <!-- ****************************************************** -->
    <h1 id="Compatibility">Compatibility</h1>

    <!-- ...................................................... -->
    <h2 id="Compatibility_JDK">Which JDK is required to use XStream?</h2>
    <p>1.3 or later.</p>

    <!-- ...................................................... -->
    <h2 id="Compatibility_JVMs">Does XStream behave differently across different JVMs?</h2>

    <p>XStream has two modes of operation: <b>Pure Java</b> and <b>Enhanced</b>. In pure Java mode,
    XStream behaves in the same way across different JVMs, however it's features are limited to what
    reflection allows, meaning it cannot serialize certain classes or fields. In <b>enhanced</b> mode,
    XStream does not have these limitations, however this mode of operation is not available to all JVMs.</p>

    <!-- ...................................................... -->
    <h2 id="Compatibility_enhanced_mode_jvm">Which JVMs allow XStream to operate in enhanced mode?</h2>

    <p>Currently on the Sun, Apple, HP, IBM and Blackdown 1.4 JVMs and onwards.
    Also for Hitachi and SAP from 1.5 and onwards.
    Support for BEA JRockit starting with R25.1.0. 
    For all other JVMs, XStream should be used in pure Java mode.</p>

    <!-- ...................................................... -->
    <h2 id="Compatibility_enhanced_mode_advantage">What are the advantages of using enhanced mode over pure Java mode?</h2>

    <table summary="Comparison of pure Java and enhanced mode">
      <tr><th>Feature</th><th>Pure Java</th><th>Enhanced Mode</th></tr>
      <tr><td>Public classes</td><td>Yes</td><td>Yes</td></tr>
      <tr><td>Non public classes</td><td>No</td><td>Yes</td></tr>
      <tr><td>Static inner classes</td><td>Yes</td><td>Yes</td></tr>
      <tr><td>Non-static inner classes</td><td>No</td><td>Yes</td></tr>
      <tr><td>Anonymous inner classes</td><td>No</td><td>Yes</td></tr>
      <tr><td>With default constructor</td><td>Yes</td><td>Yes</td></tr>
      <tr><td>Without default constructor</td><td>No</td><td>Yes</td></tr>
      <tr><td>Private fields</td><td>Yes</td><td>Yes</td></tr>
      <tr><td>Final fields</td><td>Yes &gt;= JDK 1.5</td><td>Yes</td></tr>
    </table>

    <!-- ...................................................... -->
    <h2 id="Compatibility_unsupported_JVM">Are there plans to provide enhanced mode support to other JVMs?</h2>
    <p>Yes. <a href="list-user.html">Let us know</a> which JVM you would like supported.</p>

    <!-- ...................................................... -->
    <h2 id="Compatibility_no_enhanced_mode">When should I use XStream not in enhanced mode?</h2>

    <p>Running XStream in a secured environment can prevent XStream from running in enhanced mode. This is
    especially true when running XStream in an applet. You may also try to use the JavaBeanConverter as alternative to
    the ReflectionConverter running in enhanced or pure Java mode.</p>

    <!-- ...................................................... -->
    <h2 id="Compatibility_SecurityManager">Which permissions does XStream need when running with an active SecurityManager?</h2>

    <p>This depends on the mode XStream is running in. Refer to the
    <a href="http://svn.xstream.codehaus.org/browse/xstream/trunk/xstream/src/test/com/thoughtworks/acceptance/SecurityManagerTest.java">SecurityManagerTest</a>
    for details.</p>

    <!-- ...................................................... -->
    <h2 id="Compatibility_XStream11">Why does XStream 1.2 no longer read XML generated with XStream 1.1.x?</h2>

    <p>The architecture in XStream has slightly changed. Starting with XStream 1.2 the
    <a href="javadoc/com/thoughtworks/xstream/io/HierarchicalStreamDriver.html">HierarchicalStreamDriver</a>
    implementation is responsible to ensure that XML tags and attributes are valid names in XML, in XStream 1.1.x
    this responsibility was part of the ClassMapper implementations.  Under some rare circumstances this will result in
    an unreadable XML due to the different processing order in the workflow of such problematic tag names.</p>

    <p>You can run XStream in 1.1 compatibility mode though:</p>

<div class="Source Java"><pre>XStream xstream = new XStream(new XppDriver(new XStream11XmlFriendlyReplacer())) {
    protected boolean useXStream11XmlFriendlyMapper() {
        return true;
    }
};</pre></div>

    <!-- ...................................................... -->
    <h2 id="Compatibility_ConverterAnnotations">XStream 1.3 ignores suddenly annotated converters (@XStreamConverter and @XStreamConverters)?</h2>

    <p>XStream treats now all annotations the same and therefore it no longer auto-detects any annotation by
    default.  You can configure XStream to run in auto-detection mode, but be aware if the 
    <a href="annotations-tutorial.html#AutoDetect">implications</a>.  As alternative you might register the
    deprecated AnnotationReflectionConverter, that was used for XStream pre 1.3.x, but as drawback the functionality
    to register a local converter with XStream.registerLocalConverter will no longer work.</p>


    <!-- ****************************************************** -->
    <h1 id="Serialization">Serialization</h1>

    <!-- ...................................................... -->
    <h2 id="Serialization_omit_field">How do I specify that a field should not be serialized?</h2>
    <p>Make it <code>transient</code>, specify it with <code>XStream.omitField()</code> or
    annotate it with @XStreamOmitField</p>

    <!-- ...................................................... -->
    <h2 id="Serialization_initialize_transient">How do I initialize a transient field at deserialization?</h2>

    <p>XStream uses the same mechanism as the JDK serialization. Example:</p>

<div class="Source Java"><pre>class ThreadAwareComponent {
  private transient ThreadLocal component;
  // ...
  private Object readResolve() {
    component = new ThreadLocal();
    return this;
  }
}</pre></div>

    <!-- ...................................................... -->
    <h2 id="Serialization_no_ctor_running">XStream is not calling the default constructor during deserialization.</h2>

    <p>This is, in fact, the same case as above. XStream uses the same mechanism as the JDK serialization. When using
    the enhanced mode with the optimized reflection API, it does not invoke the default constructor. The solution is to
    implement the readResolve method as above:</p>

<div class="Source Java"><pre>class MyExecutor {
  private Object readResolve() {
    // do what you need to do here
    System.out.println("After instantiating MyExecutor");
    // at the end returns itself
    return this;
  }
}</pre></div>

    <!-- ...................................................... -->
    <h2 id="Serialization_collections">What do serialized collections look like?</h2>

    <p>Example:</p>

<div class="Source Java"><pre>class Person {
  private String name;
  private List toys = new ArrayList();
  // ...
}

class Computer {
  String type;
}

class Car {
  String color;
}

xstream.alias("person", Person.class);
xstream.alias("computer", Computer.class);
xstream.alias("car", Car.class);

Person person = new Person("Joe");
person.addToy(new Computer("apple"));
person.addToy(new Computer("spectrum"));
person.addToy(new Car("blue"));

String xml = xstream.toXML(joe);</pre></div>

    <p>Results in:</p>

<div class="Source Java"><pre>&lt;person&gt;
  &lt;name&gt;Joe&lt;/name&gt;
  &lt;toys&gt;
    &lt;computer&gt;
      &lt;type&gt;apple&lt;/type&gt;
    &lt;/computer&gt;
    &lt;computer&gt;
      &lt;type&gt;spectrum&lt;/type&gt;
    &lt;/computer&gt;
    &lt;car&gt;
      &lt;color&gt;blue&lt;/color&gt;
    &lt;/car&gt;
  &lt;/toys&gt;
&lt;/person&gt;</pre></div>

	<p>Note, that it is possible to configure XStream to omit the container element <i>toys</i> using implicit collections.</p>

    <!-- ...................................................... -->
    <h2 id="Serialization_Serializable">Do my classes have to implement Serializable if XStream is to serialize them?</h2>
    <p>No.</p>

    <!-- ...................................................... -->
    <h2 id="Serialization_proxies">Can dynamic proxies be serialized?</h2>
    <p>Yes.</p>

    <!-- ...................................................... -->
    <h2 id="Serialization_CGLIB">Can CGLIB proxies be serialized?</h2>
    <p>Only limitedly. A proxy generated with the CGLIB Enhancer is supported, if the
    proxy uses only one callback and the proxy instance can be generated without
    additional constructor arguments.</p>

    <h2 id="Serialization_CGLIB_2.0.1">Serialization fails with NoSuchMethodError: net.sf.cglib.proxy.Enhancer.isEnhanced(Ljava/lang/Class;)Z</h2>
    <p>XStream uses this method to detect a CGLIB-enhanced proxy. Unfortunately the method is not available in the 
    cglib-2.0 version. Since this version is many years old and the method is available starting with cglib-2.0.1, please 
    consider an upgrade of the dependency, it works usually smoothly.</p>

    <!-- ...................................................... -->
    <h2 id="Serialization_sort_fields">Can I select the field order in which XStream serializes objects?</h2>
    <p>Yes. XStream's ReflectionConverter uses the defined field order by default. You can override it by using an specific FieldKeySorter:</p>
<div class="Source Java"><pre>SortableFieldKeySorter sorter = new SortableFieldKeySorter();
sorter.registerFieldOrder(MyType.class, new String[] { "firstToSerialize", "secondToSerialize", "thirdToSerialize" });
xstream = new XStream(new Sun14ReflectionProvider(new FieldDictionary(sorter)));
</pre></div>

    <!-- ...................................................... -->
    <h2 id="Serialization_newer_class_versions">How does XStream deal with newer versions of classes?</h2>

    <ul>
        <li>If a new field is added to the class, deserializing an old version will leave the field uninitialized.</li>
        <li>If a field is removed from the class, deserializing an old version that contains the field will cause an exception.
        Leaving the field in place but declaring it as transient will avoid the exception, but XStream will not try to deserialize it.</li>
        <li>If a class is renamed, aliases can be used to create an abstraction between the name used in XML and the real class name.</li>
        <li>if a field is renamed, this should be treated as adding a field and removing a field.</li>
    </ul>

    <p>For more advanced class migrations, you may</p>
    <ul>
	    <li>have to do custom pre-processing of the XML before sending it to XStream (for example, with XSLT or DOM manipulations)</li>
	    <li>declare new fields as transient</li>
	    <li>implement your own converter, that can handle the situation</li>
	    <li>add a readResolve() method to your class, that initializes the object accordingly</li>
    </ul>

    <p>Future versions of XStream will include features to make these type of migrations easier.</p>

    <!-- ...................................................... -->
    <h2 id="Serialization_classloader">How does XStream cope with isolated class loaders?</h2>

    <p>Serializing an object graph is never a problem, even if the classes of those objects have been loaded by
    a different class loader. The situation changes completely at deserialization time. In this case you must set the
    class loader to use with:</p>

    <div class="Source Java"><pre>xstream.setClassLoader(yourClassLoader);</pre></div>

	<p>Although XStream caches a lot of type related information to gain speed, it keeps those information in
	tables with weak references that should be cleaned by the garbage collector when the class loader is freed.</p>

    <!-- ****************************************************** -->
    <h1 id="XML">XML specifics</h1>

    <!-- ...................................................... -->
    <h2 id="XML_respect_XML_declaration">Why does XStream not respect the encoding in the XML declaration?</h2>

    <p>XStream architecture is based on IO Readers and Writers, while the XML declaration is the responsibility of XML parsers.
    XStream uses by default the Xpp3 parser which does ignore the declaration, so you have to provide a
    <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/io/Reader.html">Reader</a> with the appropriate
    encoding yourself if you do not want to read the XML in the default encoding of the current local or you must use
    a <a href="javadoc/com/thoughtworks/xstream/io/HierarchicalStreamDriver.html">HierarchicalStreamDriver</a>
    with an XML parser that respects the XML declaration.</p>

    <!-- ...................................................... -->
    <h2 id="XML_write_XML_declaration">Why does XStream not write a XML declaration?</h2>

    <p>XStream is designed to write XML snippets, so you can embed its output into an existing stream or string.
    You can write the XML declaration yourself into the Writer before using it to call XStream.toXML(writer).</p>

    <!-- ...................................................... -->
    <h2 id="XML_write_UTF8">Why does XStream not write XML in UTF-8?</h2>

    <p>XStream does no character encoding by itself, it relies on the configuration of the underlying XML writer.
    By default it uses its own PrettyPrintWriter which writes into the default encoding of the current locale. To write
    UTF-8 you have to provide a <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/io/Writer.html">Writer</a>
    with the appropriate encoding yourself.</p>

    <!-- ...................................................... -->
    <h2 id="XML_double_underscores">Why do field names suddenly have double underscores in the generated XML?</h2>

    <p>XStream maps Java class names and field names to XML tags or attributes. Unfortunately this mapping cannot
    be 1:1, since some identifiers of Java contain a dollar sign which is invalid in XML names. Therefore XStream uses an
    <a href="javadoc/com/thoughtworks/xstream/io/xml/XmlFriendlyReplacer.html">XmlFriendlyReplacer</a> to replace
    this character with a replacement. By default this replacement uses an underscore and therefore the replacer must
    escape the underscore itself also. You may provide a different configured instance of the XmlFriendlyReplacer or a
    complete own implementation, but you must ensure, that the resulting names are valid for XML.</p>


    <!-- ****************************************************** -->
    <h1 id="Other_Products">Comparison to other products</h1>

    <!-- ...................................................... -->
    <h2 id="Other_Products_XMLBeanEncoder">How does XStream compare to java.beans.XMLEncoder?</h2>

    <p>XStream is designed for serializing <i>objects</i> using internal fields, whereas
    <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/beans/XMLEncoder.html">XMLEncoder</a> is designed for
    serializing <i>JavaBeans</i> using public API methods (typically in the form
    of <code>getXXX()</code>, <code>setXXX()</code>, <code>addXXX()</code> and <code>removeXXX()</code> methods.</p>

        <!--
    <h1>Comparison to other products</h1>

    <h2>How does XStream compare to JAXB (Java API for XML Binding)?</h2>
    <p>Todo...</p>

    <h2>How does XStream compare to JSX?</h2>
    <p>Todo...</p>

    <h2>How does XStream compare to Betwixt?</h2>
    <p>Todo...</p>

    <h2>How does XStream compare to Castor?</h2>
    <p>Todo...</p>

    <h2>How does XStream compare to Electric XML?</h2>
    <p>Todo...</p>

    <h2>How does XStream compare to JOX?</h2>
    <p>Todo...</p>

    <h2>How does XStream compare to JIBX?</h2>
    <p>Todo...</p>

    -->



    <!-- ****************************************************** -->
    <h1 id="Scalability">Scalability</h1>

    <!-- ...................................................... -->
    <h2 id="Scalability_Thread_safety">Is XStream thread safe?</h2>

    <p>Yes. Once the XStream instance has been created and configured, it may be shared across multiple threads
    allowing objects to be serialized/deserialized concurrently (unless you enable the auto.detection and processing of
    annotations).</p>

    <!-- ****************************************************** -->
    <h1 id="Uses">Uses of XStream</h1>

    <!-- ...................................................... -->
    <h2 id="Uses_Data_Binding">Is XStream a data binding tool?</h2>

    <p>No. It is a serialization tool.</p>

    <!-- ...................................................... -->
    <h2 id="Uses_Generate_Code">Can XStream generate classes from XSD?</h2>

    <p>No. For this kind of work a data binding tool such as <a href="http://xmlbeans.apache.org">XMLBeans</a> is appropriate.</p>

    <!-- ...................................................... -->
    <h2 id="Uses_No_SAX_Reader">Why is there no SaxReader?</h2>

    <p>XStream works on a stream-based parser model, while SAX is event-based.  The steam based model implies, that the
    caller consumes the individual tokens from the XML parser on demand, while in an event-based model the parser
    controls the application flow on its own and will use callbacks to support client processing.  The different
    architecture makes it therefore impossible for XStream to use an event-driven XML parser.</p>

  </body>
</html>

